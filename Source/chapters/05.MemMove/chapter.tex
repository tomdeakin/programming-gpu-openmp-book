%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  
%% Chapter 5: Memory Movement
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\def\ArtDir{05.MemMove/figures}%

\chapter{Memory movement}
\label{chapter:memory}

In the previous two chapters, we have been working with the matrix multiplication program.
By placing the \BUD in front of the loop nest, we caused the loop body to execute on the target device.
We explored the first two components of this \BUD to transfer execution (and data) from the host to the device and to run the loop body in parallel on the device.

This chapter addresses the final component of the \BUD.
We will cover ways to control the data movement between the host and device explicitly.
These work in combination with the implicit data movement and provide more control over when, and what, data is transferred.

We update the matrix multiplication example from the previous chapter so that the arrays are allocated not on the stack, but on the heap. The example code in Figure~\ref{code:matmulTargetHeap} shows our final goal. In comparison to Figure~\ref{code:matmulTarget}, the matrices are passed as pointers\footnote{We have also split the \BUD onto two lines, but this is just so that that rather long directive appears nicely in print.}. As such, the data they point to will not be implicitly transferred and we must specify the movement through \Code{map} clauses.
This chapter introduces the \Code{map} clauses and the device data directives.

\begin{CodeExample}%
{\textbf{Matrix Multiplication program} --\small This program will multiply two matrices $A$ and $B$
to produce a third $C$ which has been set to zero, running on the target device.
All arrays are allocated in heap memory.
}%
{code:matmulTargetHeap}
\begin{lstlisting}
void matmul(int Ndim, int Mdim, int Pdim,
            float *A, float *B, float *C) {

  #pragma omp target map(tofrom: A[0:Ndim*Pdim], B[0:Pdim*Mdim], C[0:Ndim*Mdim])
  #pragma omp teams distribute parallel for simd collapse(2)
  for (int i = 0; i < Ndim; i++) {
    for (int j = 0; j < Mdim; j++) {
      for(int k = 0; k < Pdim; k++) {
	C[i*Mdim+j] += A[i*Pdim+k] * B[k*Pdim+i];
      }
    }
  }
}
\end{lstlisting}
\end{CodeExample}



\section{A quick recap of implicit data transfers}
%\begin{itemize}
%  \item So far only could work with scalars and stack arrays.
%  \item Now we explain heap arrays.
%  \item Recall firstprivate clause.
%  \item The pointer itself will be mapped firstprivate.
%  \item But the data needs to be mapped\dots
%\end{itemize}

Back in Chapter~\ref{chapter:target} we looked at what data is copied on entry to, and exit from, a \Code{target} region.
When a \Code{target} region is encountered, execution is transferred to the target device, and some data might be copied.
On exit, execution is returned to the host and some data might be copied back.

Scalar variables are mapped as a \Code{firstprivate} variable. This means the target has a copy of the data, but it won't be copied back to the host at the end of the target region. That variable will follow the usual sharing rules as we discussed in Chapter~\ref{chapter:overview} for any threads that are launched, and so there may be one or more copies of this variable on the device.

%What happens to a firstprivate variable when its then shared?
% #pragma omp target firstprivate(N)
% #pragma omp teams parallel ?shared(N)
% {
%  #pragma omp atomic
%  N = omp_get_team_num();
% }

Arrays declared on the stack will be copied to device memory at the start of the target region and copied back to host memory at the end. There will just be a single copy of the array, stored in device memory, that is available to all threads launched on the device. As such, it is important to know that concurrent updates to the same location of the array should be synchronized.
Non-scalar data types such as structures of a known size have the same behaviour.

This chapter will focus on arrays accessed via a pointer to data. That data is normally allocated on the heap, via a call to the \Code{malloc()} routine in the standard library. The pointer variable behaves differently to a scalar variable. The pointer is translated to an address in the device memory space at the start of the target region, but the data it points to is not copied.
This chapter will introduce the \Code{map} clause which is the primary mechanism for initiating the transfer of data accessed via a pointer.



\section{OpenMP array syntax}
\label{sec:array_syntax}
%% Array syntax: important as non-intuitive in C}
%% \begin{itemize}
%%   \item Introduce OpenMP array notation.
%%   \item array[start:length].
%%   \item It is not array[start:end] in C.
%%   \item Follows pointer size rules, so don't have to worry about sizeof(T).
%%   \item Array notation in Fortran.
%% \end{itemize}

OpenMP uses an array section syntax in order to specify a subset of elements of an array in C.
An arrays in C are pointer-based, and the square brackets used to index that pointer provide a convenient short-and for the pointer arithmetic and dereferencing.
For a C programmer familiar with the array syntax used in Fortran programs, the OpenMP syntax can be a bit unintuitive at first glance.
Array sections are passed to various OpenMP clauses, and are most often used in target device data movement and task dependencies.

For a pointer to an array \Code{var}, the syntax to define is as follows:
\begin{verbatim}
var[lower-bound : length]
\end{verbatim}
The lower bound defines the first index of the array that this array section begins at.
The length defines the number of elements, beginning at the lower bound, that are included in the array section.
For example, if \Code{var} is a pointer to an array length \Code{N} elements, the array syntax \Code{var[0:N]} would refer to the entire array: beginning at the start and running its entire length.
Note that this does not mean ``from the 0 to N`` as it might in other languages\footnote{The notation for array sections for OpenMP in Fortran uses the standard Fortran approach, and so does take this meaning there.}.

The lower bound parameter is optional, and defaults to the start of the array. As such, it is common to see array sections which just specify the length: \Code{var[:N]}. Note that we must still include the colon character.

The length is usually always included, but is optional if the size of the array is already known.
The length counts in the number of elements of the array, so we don't have to worry about the size of the underlying data type. The pointer arithmetic is taken care of, just as it is when we index into an array.

A zero-length array section takes the form \Code{var[:0]}. The length parameter is set to zero. We've already mentioned that pointers are mapped as zero-length arrays back in Section~\ref{sec:implicit_map_pointers}. As the array has zero length, the associated section of the array has no length, and so if this was used to copy data between the host and target device, no data would move. Zero-length arrays give OpenMP the information it needs about the start of the array (i.e.\ the pointer value) so that it can translate between the address space and do the required referencing counting. They won't be written in our applications very often.

It is also possible to specify a stride:
\begin{verbatim}
var[lower-bound : length : stride]
\end{verbatim}
The stride defines the number of elements to skip when selecting elements from the array.

For example, the array \Code{nums} contains the natural numbers from 0 to 1024 such at \Code{nums[i] = i} (\Code{nums[0] = 0}, \Code{nums[1] = 1}, \dots).
The array section \Code{nums[0:8:2]} would then be referring to 8 elements, starting from the beginning of the array, selecting every third element: \Code{\{0,3,6,9,12,15,18,21\}}.
We don't use strides very often when programming target devices.


\section{Sharing data explicitly with the map clause}
For data allocated on the heap, accessed via a pointer, we as programmers need to tell OpenMP what to do with it when encountering a target region.
For this we must use a \Code{map()} clause, which is associated with the \Code{target} directives.
We can explicitly control the movement of data using the \Code{map} clause.

Looking at this very simple sketch of a program below, where we allocate some memory on the heap and then start offloading to a target device.
Following the implicit rules, all the scalar variables, and the pointers, are mapped \Code{firstprivate}.
But the data that we allocated, accessed via the \Code{A} pointer is not copied at all --- it remains on the host inaccessible to the device.

\begin{Verbatim}
int N = 1024;
int* A = malloc(sizeof(int) * N);

#pragma omp target
{
  // N and A exist here, as firstprivate variables.
  // *A, A[0] (the data A points to) _does not_ exist here!
}
\end{Verbatim}

In order to make the data that \Code{A} points to available on the target device, we add the \Code{map()} clause to the \Code{target} directive.
We must use the OpenMP array syntax (recall Section~\ref{sec:array_syntax}) to describe the amount of data that needs to be copied.
By default data in a map clause is copied to the target device at the start of the target region and from the device back to the host at the end.

\begin{Verbatim}
int N = 1024;
int* A = malloc(sizeof(int) * N);

#pragma omp target map(A[0:N])
{
  // N and A exist here, as firstprivate variables.
  // *A, A[0] (the data A points to) _does_ exist here!
}
\end{Verbatim}

The \Code{map()} clause gives us lots of power and flexibility for controlling how and what data is copied between the host memory space and the target memory space (target data environment).

\subsection{The map clause}
\label{ssec:map_clause}

\begin{itemize}
%  \item Map clause on a target directive.
%  \item List notation of things to map.
%  \item to, from and tofrom.
  \item Recall the scoped behaviour: from transfer happens on the closing curly brace.
  \item alloc and delete and release.
  \item Pointer attachment from OpenMP 5.0
  \item Some mention of reference counting. Things only transfer based on that. Read the spec for the details. OpenMP 5.1 2.21.7.1 page 347.
  \item map type modifier always, close
\end{itemize}

The movement of data between the host and device in OpenMP is always defined as from the perspective of the host.
It is the host that encounters the \Code{target} directive, and what data needs to be moved is also described with this in mind.
We will always talk of ``copying data to the device'' and `copying data from the device''.
We will try to refrain from using phrases such as ``copying data from the host to the device'' as this can become confusing with the OpenMP syntax.

The \Code{map()} clause takes a list of variables to copy between the host and device, in one or both directions.
The list of variables is a comma-separated list of variables names, and you will see much in common with the usual data-sharing clauses like \Code{private}, \Code{firstprivate}, etc.

We can also specify these directions using one of the map types: \Code{to}, \Code{from} and \Code{tofrom}.
There are other modifiers (\Code{alloc}, \Code{release} and \Code{delete}) which we will use less often and will discuss them in Section~\ref{sec:TBC}.

A map type of \Code{to} will copy data that exists on the host to the device data environment on entry to the target region.
The variables are made available on the device, and they are populated with the same values as the host.
This is a copy of data to the device.

A map type of \Code{from} will copy data from the device data environment back to the host at the end of the target region.
Those device variables are copied back to their original locations on the host --- the location that is used is what was given in the \Code{map()} clause.
Note that with this map type, the mapped variables exist in the device data environment but are uninitialized.

A map type of \Code{tofrom} has the same effect as a map type of both \Code{to} and \Code{from}.
Data is then copied to the device at the start of the region, and then copied from the device back to the host at the end.
This means that the device will contain a copy of the host data, ready for use in the target region, and will return these (updated) values back to the host when the region ends.
This is the default behaviour if a map type is not specified.

It is worth noting at this point that the copying of data occurs when the target region is executed.
So far, this is straight away when the \Code{target} directive is encountered by the host.
Later, in Chapter~\ref{chapter:multi_gpu} we will introduce the mechanisms for launching target regions \emph{asynchronously}, so that the host can continue doing something else.
This distinction of when the mapping happens will make a difference there, which is why we point it out at this point.

\subsection{Example: Vector add on the heap}

To see this in action, let us go back to the Vector Add program that we first saw in Chapter~\ref{chapter:target}.
This time, in addition to parallelising it on the target device with the \BUD, we will allocate the data arrays on the heap.
The final program is shown in Figure~\ref{code:vaddTargetMap}.
The execution of the program proceeds in a very similar way to Section~\ref{sec:vadd_walkthrough}, but the data movement is different.

\begin{CodeExample}%
{\textbf{Vector Add program} --\small This program will add two vectors of length $N$
to produce a third vector, running on the target device.
}%
{code:vaddTargetMap}
\begin{lstlisting}
#define N 4000;

int main()
{

   float * A = malloc(sizeof(float) * N);
   float * B = malloc(sizeof(float) * N);
   float * C = malloc(sizeof(float) * N);

   init(A,B,C); // Set initial values

   #pragma omp target map(to: A[0:N], B[0:N]) map(from: C[0:N])
   #pragma omp teams distribute parallel for simd
   for (int i = 0; i < N; i++) {
      C[i] = A[i] + B[i];
   }
}	  
\end{lstlisting}
\end{CodeExample}

On line 12, the host encounters the target directive.
There are no scalar variables in this program that need mapping into the device data environment\footnote{The pointers to the arrays \Code{A}, \Code{B} and \Code{C} would be mapped as zero-length arrays if they had not appeared in the \Code{map()} clauses.}.
The pointers \Code{A}, \Code{B} and \Code{C} appear in the \Code{map()} causes.
We have used the OpenMP array syntax to show the extent of those arrays.
For example, \Code{A[0:N]} describes the full extent of the array \Code{A}: \Code{N} elements starting from the beginning of the array.
The map types define when data is copied between the host and device.
On line 12, at the start of the target region, the \Code{map(to:...)} clause will be invoked and the variables will be copied to the device.
In this program, it is the arrays \Code{A} and \Code{B} that are copied at the start of the target region.

We use a different map type for the array \Code{C}: \Code{map(from:...)}.
This will ensure there is memory allocated for the array \Code{C} on the device, but it will be uninitialized.
This is perfect for our loop where we write to this array, and do not read to it inside the target data region.
The \Code{map(from:...)} clause therefore does not copy anything to the device at this point.
But it will later copy the array from the device back to the host.
This will occur at the end of the target region: between lines 16 and 17 in the example.
Once the array \Code{C} has been copied back to the host, the target region has ended and so execution returns back to the host.

There is a lot of similarity here to how the vector addition program from Figure~\ref{code:vaddTarget} behaved.
In the first example, the arrays were on the stack and the OpenMP runtime was able to automatically copy the data arrays.
In this example where the arrays are on the heap instead, we add the \Code{map()} clauses to cause the same data copies to occur.
These copies need to happen for the program be correct.
With more complex examples, we will start to see how having control of the data movement gives us significant opportunity to optimizing the data movement beyond what would be possible with the implicit rules.

\section{Mapping Matrix Multiplication}
We have now covered enough about memory movement to cover the matrix multiplication example in Figure~\ref{code:matmulTargetHeap} introduced at the very beginning of this chapter.
The \Code{map(tofrom: A[0:Ndim*Pdim], B[0:Pdim*Mdim], C[0:Ndim*Mdim])} clause on the \Code{target} directive describes the data copies required.
The OpenMP array syntax is used to show the extents of each of the three arrays.
In this case, they are all different sizes. Note how we can have a expression in the clause.

The \Code{tofrom} map type is used so that all the arrays are copied to the device at the start of the target region, and then all three are copied from the device back to the host at the end of the target region.
Just like the vector addition program in Figure~\ref{code:vaddTargetMap}, the matrix multiplication program only updates one of the arrays, and that two of the arrays are only read from.
As an optimization we could therefore map the \Code{A} and \Code{B} arrays with the \Code{to} map type.
They do not change value in the target region and so it is wasteful to copy them back to the host.

Importantly however, we must ensure that the \Code{C} array is properly initialized on the device.
It would not be enough to use a \Code{from} map type because we use the \Code{+=} operator inside the target region.
The original value of \Code{C} is updated, and so we must ensure this array in the target data environment is correctly initialized.
We also must copy it back at the end of the target region so that the host can use the result of the matrix multiplication.
We ensured the data would be copied at the beginning and end of the target region by using a \Code{tofrom} map type.

In the remainder of this chapter, we will cover data movement optimizations to try to reduce the number of data copies where we wish data to remain resident on the target device between target regions.

\section{Reductions and mapping back result.}
\label{sec:target_reductions}
%% \begin{itemize}
%%   \item In OpenMP 5, the reduction result is brought back automatically.
%%   \item Need to add a note that in OpenMP 4.5, need to use the map clause to do a reduction on the device.
%%   \item map(tofrom: scalar)
%%   \item Explain that without this it is firstprivate and not copied back.
%%   \item Explain interaction of reduction clause with teams and threads and simd in the OpenMP hierarchy of parallelism.
%% \end{itemize}

What happens to variables that appear in \Code{reduction} clauses?
We know (from Chapter~\ref{chapter:overview} that variables cannot appear in more than one data sharing clause\footnote{Other than appearing in both \Code{firstprivate} and \Code{lastprivate}.}.
This means the same list item cannot be put into both a \Code{reduction} clause and a \Code{map} clause on the same OpenMP directive.
We need to know what happens for reduction variables.

What you have to do depends a little on how we write out OpenMP directives.
There are two cases we'll look at: first, the combined directives, such as the \BUD; and secondly where we split out the \Code{target} directive on its own line in the source code.

When we use a combined construct like the \BUD to run our parallel loops on a target device, if that loop is a reduction, we will need to add a \Code{reduction} clause for the reduction variable.
This indicates to OpenMP that a reduction needs to take place, and it will do the right thing to compute the final, reduced result.
Where does this result go when it's ready?
When we use a combined construct, that is one that begins \Code{target teams}, the reduction variable will implicitly also be mapped \Code{tofrom}.
So for a variable \Code{sum}, by stating it is a reduction variable with the reduction clause as \Code{reduction(+:sum)}, it additionally behaves as if there was also a \Code{map(tofrom:sum)} clause present\footnote{See the OpenMP 5.1 specification, page 254, lines 4--7.}.
This means that when the target region begins executing, the original value is copied to the target device, the reduction is executed, and the result is copied back to the host at the end of the target region execution.

To see this in action, let's look back at our program which computed Pi from earlier (\ref{the_pi_example}).
Figure~\ref{code:piTarget} shows the program which runs on the target device.
We use the \BUD for parallel execution along with the \Code{reduction} clause, but we are going to focus on the data mapping.
The variables inside the target region are: \Code{step}, \Code{sum}, and \Code{i}.
The \Code{i} is the loop iteration variable, and so it by default \Code{private}.
The \Code{step} scalar variable is mapped \Code{firstprivate} according to the implicit data mapping rules back in Section~\ref{sec:implicit_map_scalars}.
Finally, there is the \Code{sum} variable, but this is listed in the \Code{reduction} clause: it is a reduction variable.
Therefore, it behaves as if a \Code{map(tofrom: sum)} was also present on the directive (line 7).
The variable is copied to the device at the start of the target region.
Once the reduction has finished, the final scalar result will be copied back to the host at the end of the target region.

\begin{CodeExample}%
{\textbf{Pi program} --\small This program will compute pi on the target device.
Note how the result is implicitly mapped from the device to the host.
}%
{code:piTarget}
\begin{lstlisting}
#include <stdio.h>
static long num_steps = 100000000;
int main() {
  double sum = 0.0;
  double step = 1.0 / (double)num_steps;

  #pragma omp target teams distribute parallel for simd reduction(+:sum)
  for (int i = 0; i < num_steps; i++) {
    double x = (i + 0.5) * step;
    sum += 4.0 / (1.0 + x * x);
  }

  double pi = step * sum;
  printf(" pi with %ld steps is %lf\n", num_steps, pi);
}
\end{lstlisting}
\end{CodeExample}

We might wonder what an OpenMP implementation has to do to compute the final reduction result.
Each OpenMP team will have some partial reduction value.
But there is no way to synchronize between OpenMP teams, that is until the target region finishes executing.
An OpenMP implementation is responsible for completing the reduction operation, collating the result from each team and returning the value to the host.
The way it does this is going to depend on the type of target device, and on the quality of implementation.
As such, by using the \Code{reduction} clause itself, we can ensure that our programs are likely going to perform well on different devices.

Now to address the other case, where we split the combined \Code{target teams} directive across two lines, so that the \Code{target} and \Code{teams} directives are separate.

\begin{CodeExample}%
{\textbf{Pi program} --\small This program will compute pi on the target device.
Note how the result is implicitly mapped from the device to the host.
}%
{code:piTargetInReduction}
\begin{lstlisting}
#include <stdio.h>
static long num_steps = 100000000;
int main() {
  double sum = 0.0;
  double step = 1.0 / (double)num_steps;

  #pragma omp target in_reduction(+:sum)
  #pragma omp teams distribute parallel for simd reduction(+:sum)
  for (int i = 0; i < num_steps; i++) {
    double x = (i + 0.5) * step;
    sum += 4.0 / (1.0 + x * x);
  }

  double pi = step * sum;
  printf(" pi with %ld steps is %lf\n", num_steps, pi);
}
\end{lstlisting}
\end{CodeExample}

%%
%% TODO: target in\_reduction clause. Will always be mapped tofrom, 5.1:254:8--10. Will come back to this later because no compiler currently supports this clause.
%%

\subsection{Here be dragons: reductions in OpenMP 4.5}
In OpenMP 4.5, there was a small oversight in the specification where the above rule had to be broken in order to collect the result of a reduction.
If you just used a \Code{reduction} clause, as we do now, the implicit mapping rules were applied and the reduction variable was unfortunately mapped as \Code{firstprivate}, which meant there was no way to get the result back!
The reduction variable (\Code{sum}) needed to be placed in the \Code{reduction} clause so that the reduction operation happened, but it also needed to be used in a \Code{map} clause so that the host could recover the result.
Figure~\ref{code:omp45Reduction} shows what was required to generate correct answers.
All major compilers supported this so that reductions were functional, despite the violation of the rules.

This was of course resolved in later versions of the OpenMP specification, beginning with version 5.0.
It is unlikely that there are many OpenMP implementations that do not yet support this OpenMP 5.0 feature, but it is useful to be aware of this just in case.
Most major OpenMP implementations now support this part of the OpenMP 5.0 specification so that we can write our OpenMP programs correctly following the new standard just as we have explained in the main part of Section~\ref{sec:target_reductions}.

\begin{CodeExample}%
{\textbf{OpenMP 4.5 reduction mapping example} --\small In OpenMP 4.5, developers had to ignore the specification and include
the reduction variable in the reduction clause and the map clause. This is no longer allowed (or necessary) in OpenMP 5.0.
}%
{code:omp45Reduction}
\begin{lstlisting}
#define N 1024
int A[1024]; init(A);

double sum = 0.0;

#pragma omp target teams distribute parallel for simd reduction(+:sum) map(tofrom:sum)
for (int i = 0; i < N; ++i) {
  sum += A[i];
}

printf("sum=%lf\n", sum);
\end{lstlisting}
\end{CodeExample}


\section{Data regions}
\begin{itemize}
  \item Motivation: so far expressed data movement for each target region.
  \item Wasteful as can often just leave it there between target regions.
  \item Multiple target regions, leaving data resident.
  \item Motivating example: multiple subsequent transformations to data, and/or iterative solve.
  \item Wasteful as only want to do the mapping: both writing and in terms of optimal data movement.
  \item Idea of target data region. Inherited by target regions. Data already exists on the device.
\end{itemize}

\subsection{Target data directive}
\label{ssec:target_data}
\begin{itemize}
  \item Scoped target data region.
  \item Useful for lots of kernels running after each other.
  \item Show an example of this.
  \item No need to map on the target regions themselves.
  \item Downsides are the structured block requirements.
  \item From destination determined at start of region.
\end{itemize}

\subsection{Target enter/exit data}
\label{ssec:target_enter_exit_data}
\begin{itemize}
  \item Change target data environment in unstructured way.
  \item Expect will need to talk about reference counting again.
  \item Useful because don't need scoped. But behaves similarly.
  \item Example use just after every allocation.
  \item Means this helps with C++ class data in constructors.
  \item Example: Show the same target data example with the target enter/exit data.
\end{itemize}

\subsection{Target update directive}
\label{ssec:target_update}
\begin{itemize}
  \item Need to get data back in the middle of target data region.
  \item target update directive.
  \item Uses same map clauses as before.
  \item Example: convergence, or halo exchange.
\end{itemize}

\subsection{Pointer swapping}
\begin{itemize}
  \item Pointers are mapped firstprivate and zero-length arrays.
  \item Updates reference count.
  \item Doesn't need to copy any data, and don't need to specify length as already mapped.
  \item Will be remapped/reevaluated on each target region.
  \item How do you do pointer swapping in a target data region.
  \item How do you do pointer swapping when you use target enter/exit.
  \item Note that mapping happens at execution, but uses information when encountered.
\end{itemize}

\section{Example: Jacobi or CG or simple linear solver.}
\begin{itemize}
  \item Biggest example, showing off everything so far.
  \item Key requirements: iterative and pointer swap to motivate cutting down memory movement
  \item Use target enter/exit data regions.
  \item Use pointer swapping.
  \item Use target update.
  \item Uses parallelism, with/without reduction clause.
\end{itemize}


\section{Advanced parts}

\begin{itemize}
  \item The idea of original and corresponding variables.
  \item Device data environment formal definition.
\end{itemize}


\subsection{Declare target}
\label{ssec:declare_target}
\begin{itemize}
  \item map global variables
\end{itemize}


\subsection{User-defined mappers}
\label{sec:mapper}
\begin{itemize}
  \item From OpenMP 5.0
  \item Allow user to define how structures are mapped.
  \item Useful for complex structures
  \item Example: struct with a pointer variable. Declare mapper of struct which also maps the pointer.
\end{itemize}

\subsection{Allocator and memcpy APIs and related clauses}
\label{sec:alloc_apis}
\begin{itemize}
  \item \Code{omp\_target\_alloc()}
  \item \Code{omp\_target\_free()}
  \item \Code{use\_device\_ptr}
  \item allocate, test, and move memory using the APIs instead of the pragmas.
\end{itemize}


%-----------------------------------------------------------------------
%------------------------- From Next Step ------------------------------
%-----------------------------------------------------------------------
\section{From The Next Step Chapter 6}
\subsection{Data Mapping Clauses}
\label{sec:06.data-mapping-clauses}

\index{Accelerators!Device data environment}
\index{Device data environment}
Recall from Section~\ref{ssec:06.device-data-environments} that an accelerator has a
\emph{device data environment}, which contains the set of all variables that are
available to the threads executing on that accelerator.  When an 
\emph{original}~\emph{variable} in the host's data environment is mapped to an accelerator, a
\emph{corresponding}~\emph{variable} is allocated in the accelerator's device data
environment.  During the execution of a program, the set of corresponding
variables in an accelerator's device data environment will change as variables
are mapped and unmapped from it.

Depending on the memory architecture of the heterogeneous system, the original
and corresponding variables may or may not share the same storage location.
Because of this, a user must consider these two aspects of mapped
variables: \begin{itemize}

    \item Because the original and corresponding variables \emph{may} share the
    same storage location, a mapped variable should be thought of like a shared
    variable.  This means that if either the original or the corresponding
    variable is written to by a thread, synchronization and memory consistency
    operations are required to avoid data races.

    \item Because the original and corresponding variables \emph{may not} share
    the same storage location, copy operations might be required to make the
    original and corresponding variables consistent.  These copy operations can
    be costly in regards to performance and should be
    avoided if possible.

\end{itemize}

If a variable is accessed in a target
region, but the variable does not appear as a list item in a \code{map} clause
on the construct then there are default rules to determine if the variable is
mapped or private.  These rules and the \code{defaultmap} clause are covered in
Section~\ref{ssec:06.defaultmap-clause}.  Structure members may appear as list
items in a \code{map} clause but with some limitations that are described in
Section~\ref{ssec:06.map-structs}.
Section~\ref{ssec:06.zero-array-sections} shows how to access
previously mapped memory using pointer-based array sections with a length of
zero.

%Section~\ref{ssec:06.zero-array-sections} covers what happens when an
%array section with a length of zero appears in a \code{map} clause.


%-----------------------------------------------------------------------
%------------------------- New subsection ------------------------------
%-----------------------------------------------------------------------
\subsubsection{The Map Clause}
\label{sec:06.map-clause}
\index{OpenMP clauses!map}
\index{Accelerators!Map clause}

\index{Accelerators!Array section}
\index{Array section}
Variable names, array sections, and structure elements may appear as list items
in a \code{map} clause.  An optional \emph{map-type} and \code{always}
\emph{map-type-modifier} control how the list items are mapped.  The syntax of
the \code{map} clause is shown in Figure~\ref{figure:syntax-map-clause}.  If no
\emph{map-type} is specified, the default is \code{tofrom}.

\index{Mapped variable}
\index{Mapped variable!Map-type}
\index{Mapped variable!Alloc map-type}
\index{Mapped variable!To map-type}
\index{Mapped variable!Delete map-type}
\index{Mapped variable!From map-type}
\index{Mapped variable!Release map-type}
\index{Mapped variable!Tofrom map-type}
\index{Mapped variable!Always map-type-modifier}
\begin{figure}[!b]
\centering
\begin{tabular}{|l|}
\hline
\code{map} \emph{([[map-type-modifier[,]] map-type:] list)} \\
\hline
where the optional \emph{map-type} is one of:  \\
\hspace{2em}\code{alloc} \\
\hspace{2em}\code{to} \\
\hspace{2em}\code{from} \\
\hspace{2em}\code{tofrom} \\
\hspace{2em}\code{release} \\
\hspace{2em}\code{delete} \\
\hline
where the optional \emph{map-type-modifier} is:  \\
\hspace{2em}\code{always} \\
\hline
\end{tabular}
\caption{ \textbf{Syntax of the map clause in C/C++ and Fortran} -- \small
          The map clause controls how variables are mapped.
          }
\label{figure:syntax-map-clause}
\end{figure}

\index{Mapped variable!Map-enter phase}
\index{Mapped variable!Map-exit phase}
There are three phases that occur when mapping a variable in a \code{target}
region: \begin{enumerate}
    \item The \emph{map-enter} phase occurs on entry to the \code{target}
    region when the variable is mapped to the accelerator.  
    \item The \emph{compute} phase occurs when, during the execution of the
    \code{target} region, threads executing on the accelerator access the
    mapped variable.
    \item The \emph{map-exit} phase occurs on exit from a \code{target} region
    when the variable is unmapped from the accelerator.  
\end{enumerate}

The map-enter and map-exit phases manage the storage allocation and copy
operations for a mapped variable.
In the map-enter phase storage is allocated for the variable in the accelerator's
address space, and then the value of host's original variable is copied to the 
accelerator's corresponding variable.
In the map-exit phase, the value of the accelerator's corresponding variable 
is copied to the host's original variable, and then the storage for the 
corresponding variable in the accelerator's address space is released.
    
%The map-enter and map-exit phases manage the storage allocation and copy
%operations for a mapped variable as follows:
%
%In the map-enter phase: \begin{list}
%  \item Allocate storage for the corresponding variable in the accelerator's
%  address space.
%  \item Copy the value of the host's original variable to the accelerator's
%  corresponding variable.
%\end{list}
%
%  \item compute phase: \begin{itemize}
%    \item Threads running on the accelerator access the corresponding variable
%    during the execution of a target region.
%  \end{itemize}
%
%In the map-exit phase: \begin{enumerate}
%  \item Copy the value of the accelerator's corresponding variable to the
%  host's original variable.
%  \item Release the storage for the corresponding variable in the accelerator's
%  address space.
%\end{enumerate}

In Figure~\ref{figure:chapter6-map-v1}, the map-enter phase occurs on entry to
the target region at line $3$.  Storage is allocated for the three
corresponding arrays \code{a}, \code{b} and \code{t} in the accelerator's address space.  The
values of the host's original \code{a}, \code{b} and \code{t} array variables are then copied
to the accelerator's corresponding array variables. 

\begin{figure*}[!b]
\begin{verbatim}
 1 #include <stdlib.h>
 2 void func(float a[1024], float b[1024], int t[1024])
 3 {
 4   #pragma omp target map(a, b, t) // Map-enter
 5   {
 6     int i;
 7 
 8     for (i=0; i<1024; i++)
 9       t[i] = rand()%1024;
10 
11     for (i=0; i<1024; i++)
12       a[i] =  b[t[i]];
13 
14   } // End of target, map-exit
15 }
\end{verbatim}
\caption{ \textbf {Example of the map clause} -- \small
          Copies occur for the arrays \texttt{a}, \texttt{b}, and 
          \texttt{t} at the entry to and exit from the target region.
         }
\label{figure:chapter6-map-v1}
\end{figure*}

The map-exit occurs on exit from the target region at line $14$.  The values of
the accelerator's corresponding array variables are copied back to the host's
original array variables, and the storage for the three variables in the
accelerator's address space is then released.

Notice that, in the compute phase, the arrays \code{a} and \code{t} are only written to and
that array \code{b} is only read from.  Let's assume that \code{t} is a temporary variable, and
that the values written to it are never used after the target region.  It is
apparent then that the copies for \code{a} and \code{c} that occur during the map-enter
phase are not needed.  Further, the copies that occur during the map-exit phase
for \code{b} and \code{c} are not needed.  

\index{Mapped variable!Map-enter phase}
\index{Mapped variable!Map-exit phase}
The \code{map} clause's \emph{map-type} is used to optimize the copies that
occur during the map-enter and map-exit phases. On many heterogeneous systems,
it is costly to copy variables between the host and an accelerator.  The
\emph{map-type} is used to disable these copies as shown in
Figure~\ref{figure:chapter6-map-types}.

\index{Mapped variable}
\index{Mapped variable!Map-type}
\index{Mapped variable!Alloc map-type}
\index{Mapped variable!To map-type}
\index{Mapped variable!Delete map-type}
\index{Mapped variable!From map-type}
\index{Mapped variable!Release map-type}
\index{Mapped variable!Tofrom map-type}
\begin{figure*}[!b]
\centering
\begin{tabular}{|l l l|}
\hline
\code{map-type} & Perform map-enter copies & Perform map-exit copies \\
\hline
\code{alloc} & No & No \\
\code{to} & Yes & No \\
\code{from} & No & Yes \\
\code{tofrom} & Yes & Yes \\
\code{release} & -- & No \\
\code{delete} & -- & No \\
\hline
\end{tabular}
\caption{ \textbf{Map-type effect on mapping variables} -- \small
          The default \emph{map-type} is \texttt{tofrom}.  The \texttt{release}
          and \texttt{delete} \emph{map-types} apply only to the map-exit phase
          and can only appear in a \texttt{map} clause on a
          \texttt{target}~\texttt{exit}~\texttt{data} construct (See
          Section~\ref{ssec:06.target-enter-and-exit-data-constructs}).
        }
\label{figure:chapter6-map-types}
\end{figure*}

In Figure~\ref{figure:chapter6-map-v2} the code from
Figure~\ref{figure:chapter6-map-v1} is updated to use explicit map-types.  The
map-enter phase occurs on entry to the target region at line $4$ and
storage is allocated for the three corresponding arrays \code{a}, \code{b} and \code{t} in the
accelerator's address space.  Only the value of the host's original \code{b} array
variable is copied to the accelerator's corresponding \code{b} array variable. The
corresponding \code{a} and \code{t} array variables are left uninitialized.  The map-exit
phase occurs on exit from the target region at line $15$.  Only the
value of the accelerator's corresponding \code{a} array variable is copied to the
host's original \code{a} array variable.  The storage in the accelerator's address
space for all three variables is then released.  Using map-types, unnecessary
copy operations have been eliminated.

\begin{figure*}[!tb]
\begin{verbatim}
 1 #include <stdlib.h>
 2 void func(float a[1024], float b[1024], int t[1024])
 3 {
 4   #pragma omp target map(from:a) map(to:b) \
 5                      map(alloc:t) // Map-enter
 6   {
 7     int i;
 8 
 9     for (i=0; i<1024; i++)
10       t[i] = rand()%1024;
11 
12     for (i=0; i<1024; i++)
13       a[i] =  b[t[i]];
14 
15   } // End of target, map-exit
16 }
\end{verbatim}
\caption{ \textbf {Example of the map clause with map-types} -- \small
          Eliminate superfluous copies by using map-types.
         }
\label{figure:chapter6-map-v2}
\end{figure*}

On entry to a \code{target}, \code{target}~\code{data}, or
\code{target}~\code{enter}~\code{data} construct, a map-enter phase occurs.
Likewise, on exit from a \code{target}, \code{target}~\code{data}, or
\code{target}~\code{exit}~\code{data} construct, a map-exit phase occurs.
The \code{target}~\code{data}, \code{target}~\code{enter}~\code{data}, and
\code{target}~\code{exit}~\code{data} data mapping constructs only map
variables and do not execute any code on an accelerator (see
Section~\ref{sec:06.data_mapping_constructs}).

What happens when a construct maps a variable, but that variable has already
been mapped by a \code{target}~\code{enter}~\code{data} construct or by an
enclosing \code{target}~\code{data} construct?  
There can be only one instance of a corresponding variable in an accelerator's
device data environment.  A reference count is associated with each
corresponding variable.  When a variable is \emph{present} in an accelerator's
device data environment, its corresponding variable's reference count is
greater than or equal to one.
The map-enter and map-exit phases increment or decrement the
corresponding variable's reference count.  The point of the reference count is
to keep track of the number of times a variable has been mapped and to only
remove it from the accelerator device data environment after it has been
unmapped the same number times.

In the code in
Figure~\ref{figure:chapter6-map-v3} 
\code{target}~\code{data} construct at line $5$ maps the variables \code{a}, \code{b} and
\code{t} according to their respective map-types.  
However, the variables \code{a}, \code{b} and \code{t}
are mapped again by the enclosed \code{target} constructs at lines $8$ and $16$.

\begin{figure*}[!tb]
\begin{verbatim}
 1 #include <stdlib.h>
 2 #include <stdio.h>
 3 void func(float a[1024], float b[1024], int t[1024])
 4 {
 5   #pragma omp target data map(from:a) map(to:b) \
 6                           map(alloc:t) // Map-enter
 7   {
 8     #pragma omp target map(always,from:t) // Map-enter
 9     for (int i=0; i<1024; i++) {
10       t[i] = rand()%1024;
11     } // Map-exit
12 
13     for (int i=0; i<1024; i++)
14        printf("t[%d]=%d\n", i, t[i]);
15 
16     #pragma omp target map(a,b,t) // Map-enter
17     for (int i=0; i<1024; i++) {
18       a[i] =  b[t[i]];
19     } // Map-exit
20 
21   } // End of target data, map-exit
22 }
\end{verbatim}
\caption{ \textbf {Example of a variable appearing in nested map clauses} -- \small
          There is only one instance of a variable in an accelerator's
          address space.
         }
\label{figure:chapter6-map-v3}
\end{figure*}

The \code{target}~\code{data} construct's map-enter phase at line $5$ allocates
storage in the accelerator's address space for the variables \code{a}, \code{b} and \code{t}.
Only the corresponding variable \code{a} is assigned the value of the host's
original \code{a} variable.  The \code{b} and \code{t} corresponding variables are
uninitialized.

\index{Mapped variable}
\index{Mapped variable!Map-type}
\index{Mapped variable!Always map-type-nodifier}
The target construct's map-enter phase at line $8$ does not allocate storage
for the variable \code{t}, because \code{t} is already present in the accelerator's device
data environment.  The \code{always} \emph{map-type-modifier} combined with the
\code{from} \emph{map-type} forces a copy of \code{t} from the accelerator to the host
during the map-exit phase at the end of the target region at line $11$.

\index{Mapped variable!Map-enter phase}
The target construct's map-enter phase at line $16$ does not allocate storage
or copy the variables \code{a}, \code{b} and \code{t} to the accelerator, because they are
already present in the accelerator's device data environment.  Likewise, the
map-exit phase at line $19$ does not copy the variables back to the host or
release the storage on the accelerator.  In this case, it is as if the effects
of the \code{map} clause are ignored.

\index{Mapped variable!Map-exit phase}
Finally, at line $20$ the map-exit phase for the \code{target}~\code{data}
construct copies the value of the \code{b} from the accelerator and then releases
the storage for all three variables.

%To briefly review, the map-enter phase for a variable includes two conditional
%actions: 1) storage allocation and 2) a copy operation to the accelerator.
%Likewise, the map-exit phase for a variable includes the following two conditional actions: 1)
%a copy operation from the accelerator and 2) storage release.  

%The allocation and release of storage actions are  conditioned to occur based
%on the reference count.  Further, the copy operations are conditioned to occur
%depending on the \emph{map-type} and \code{always} \emph{map-type-modifier}.

At the start of the map-enter phase, if a corresponding variable's
reference count is greater than or equal to one, then no new storage is allocated,
and the value of the original variable is not copied to the corresponding
variable.  The only effect is that the reference count is incremented.

Likewise, at the start of a map-exit phase, if a corresponding variable's
reference count is greater than one, then the value of the corresponding
variable is not copied back to the original variable, and its storage is not
released.  The only effect is that the reference count is decremented.

%In the map-enter phase, when a mapped variable's map-type is \code{to} or
%\code{tofrom}, a copy to a corresponding variable occurs only when the
%reference count is incremented to one (such as when the corresponding variable is
%entered into the accelerator's data environment).

%Similarly, in the map-exit phase, when a mapped variable's map-type is
%\code{from} or \code{tofrom}, a copy from a corresponding variable
%only occurs when the reference count is decremented to zero (such as when the corresponding
%variable is removed from the accelerator's device data environment).

The \code{always} \emph{map-type-modifier} asserts that the map-enter and
map-exit copies should occur regardless of the reference count.  It
provides a way to force a copy to occur.

\index{Mapped variable}
\index{Mapped variable!Map-type}
\index{Mapped variable!Alloc map-type}
\index{Mapped variable!To map-type}
\index{Mapped variable!Delete map-type}
\index{Mapped variable!From map-type}
\index{Mapped variable!Release map-type}
\index{Mapped variable!Tofrom map-type}
\index{Mapped variable!Always map-type-nodifier}
The steps associated with the map-enter and map-exit phases are updated to
incorporate the reference count, \emph{map-type}, and \emph{map-type-modifier}
as shown below:

The map-enter phase: \begin{enumerate}

  \item If a corresponding variable is not present in the accelerator's device
  data environment then: \begin{itemize}
     
    \item Allocate storage in the accelerator's address space for the
    corresponding variable, and initialize its reference count to zero.

  \end{itemize}

  \item Increment the corresponding variable's reference count by one.

  \item If the \code{to} or \code{tofrom} map-type is specified then:
  \begin{itemize}

    \item If the corresponding variable's reference count is one or the
    \code{always} \emph{map-type-modifier} is specified, then assign the value of the
    host's original variable to the accelerator's corresponding variable.

  \end{itemize}

\end{enumerate}

The map-exit phase: \begin{itemize}

  \item If a corresponding variable is present in the accelerator's device
  data environment then: \begin{enumerate}

    \item If the \code{from} or \code{tofrom} \emph{map-type} is specified
    then: \begin{itemize} 
    
      \item If the corresponding variable's reference count is one or the
      \code{always} \emph{map-type-modifier} is specified, then assign the value
      of the accelerator's corresponding variable to the
      host's original variable.

    \end{itemize}

    \item Decrement the corresponding variable's reference count by one.

%    \item If the \code{delete} \emph{map-type} is specified, then set the
%    corresponding variable's reference count to zero.

    \item If the \code{delete} \emph{map-type} is specified and the
    corresponding variable's reference count is not infinite, then
    set it to zero.

    \item If the corresponding variable's reference count is zero, then release the storage
    for the corresponding variable in the accelerator's address space.

  \end{enumerate}

\end{itemize}

Although the \code{alloc} and \code{release} \emph{map-types} do not appear
explicity above, their effect is to either decrement or increment the reference count.  
The \code{delete} \emph{map-type} sets the reference count to zero.  It
provides a way to force the removal of a variable from an accelerator's device
data environment.  
Globally mapped variables and device memory associated to host memory by the
\code{omp_target_associate_ptr()} function have an infinite reference count and
cannot be removed.
Both the \code{delete} and \code{release} \emph{map-types}
may appear only in \code{map} clauses on the
\code{target}~\code{exit}~\code{data} construct (see Section~\ref
{ssec:06.target-enter-and-exit-data-constructs}).
\index{Accelerators!omp\_target\_associate\_ptr} 
\index{OpenMP runtime functions!omp\_target\_associate\_ptr} 
\index{Mapped variable!Globally mapped}

%-----------------------------------------------------------------------
%------------------------- New subsection ------------------------------
%-----------------------------------------------------------------------
\subsubsection{Mapping Structure Members}
\label{ssec:06.map-structs}
\index{OpenMP clauses!map}
\index{Accelerators!Map clause}
\index{Mapped variable!Structure member}

Similar to how an array section can map a subset of the elements in an array,
individual structure members can appear in \code{map} clauses in order to map
a subset of the members in a structure variable.  The restrictions on mapping
structure members are as follows:

\begin{itemize}

 \item Structure members must explicitly appear in \code{map} clauses,
 otherwise a reference to a structure member in a \code{target} construct
 implicitly maps the whole structure.

 \item To map a subset of the members in a structure variable, 
 all structure members in the subset must appear in a \code{map} clause(s) on the same
 construct.

 \item If a subset of members of a structure variable are mapped, only the
 structure members in the subset can be referenced in a \code{target} region.

 \item When a subset of members of a structure variable are mapped, the
 subset may not be increased by additionally mapping other members of the
 structure variable.

 \item C/C++ structure members with type pointer may appear as the base of an
 array section, but only the rightmost structure member can specify an array
 section.  For example, \code{S.a[:100]} is legal syntax, but \code{S.b[:100].z} is not.
 \index{Mapped variable!Array section}
 \index{Array section!Pointer-based}
 \index{Array section!Structure member}

\end{itemize}

\index{Accelerators!Mapped function}
To illustrate these concepts, some simple use cases are presented in
Figure~\ref{figure:chapter6-mapstruct}.  A structure type \code{Stype} is declared
at line $1$. Lines $3-4$ use the \code{declare}~\code{target} construct to declare that
\code{f1()}, \code{f2()}, and \code{f3()} are mapped functions and may be called from a target region 
(see Section~\ref{sec:06.declare-target-construct}).

\begin{figure*}[!tb]
\begin{verbatim}
 1 typedef struct { int x, y, size, *p; } Stype;
 2 extern Stype S;
 3 extern int f1(int,int), f2(int*,int), f3(Stype *);
 4 #pragma omp declare target to(f1, f2, f3) 
 5 
 6 void foo1(Stype S)
 7 {
 8    #pragma omp target
 9    f1(S.x, S.y);
10 
11    #pragma omp target map(S.x, S.y)
12    f1(S.x, S.y);
13 
14    #pragma omp target map(S, S.p[:S.size])
15    f2(S.p, S.size);
16 
17    #pragma omp target map(S.x)
18    f3(&S);
19 
20    #pragma omp target data map(S.x)
21    {
22       #pragma omp target map(S.y) // Error
23       f1(S.x, S.y);
24    }
25 }
\end{verbatim}
\caption{ \textbf {Example of mapping structure members} -- \small
          Structure members may appear in map clauses and array sections with some
          restrictions.
         }
\label{figure:chapter6-mapstruct}
\end{figure*}

For the \code{target} construct at line $8$, the whole structure variable $S$
is mapped even though only the members \code{S.x} and \code{S.y} are referenced in the
construct.  The structure members \code{S.x} and \code{S.y} appear explicitly in
a \code{map} clause on the \code{target} construct at line $11$, and now only
these two members are mapped instead of the whole structure variable \code{S}.  The
\code{map} clause on the \code{target} construct at line $14$ has an array
section where \code{S.p} is used as the base of the array section.

On line $17$, only \code{S.x} is mapped, but the call at line $18$ refers to the
address of \code{S}.  This is allowed as long as the code inside the function \code{f3()}
accesses only \code{S.x}.  In the last example that spans lines $20-24$ the structure
member \code{S.x} is mapped by the \code{target}~\code{data} construct at line
$20$.  The \code{target} construct then maps \code{S.y}.  This is an error because
it tries to change the subset of mapped structure members (the fourth
restriction above).  This may be remedied by adding \code{S.y} to the \code{map}
clause on line $20$.

%-----------------------------------------------------------------------
%------------------------- New subsection ------------------------------
%-----------------------------------------------------------------------
\subsubsection{The Defaultmap Clause and Data-mapping Attributes}
\label{ssec:06.defaultmap-clause}
\index{OpenMP clauses!defaultmap}
\index{Accelerators!Defaultmap clause}

\index{Mapped variable!Data-mapping attribute}
If and how a variable is mapped is determined by the variable's data-mapping
attributes.  
%If a variable is not mapped in a \code{target} construct, it is
%\code{private} or \code{firstprivate}.  
The rules for determining the
data-mapping attributes for a variable are either explicitly or implicitly
determined.

\index{Mapped variable}
\index{Mapped variable!Map-type}
\index{Mapped variable!Default map-type}
The data-mapping attributes for variables that appear in clauses or are
declared in a scope inside the \code{target} construct are explicitly determined
according to the following rules: \begin{itemize}

  \item A variable that appears in a \code{map} clause is mapped according to
  the \emph{map-type}.

  \item A variable that appears in a \code{private}, \code{firstprivate}, or
  \code{is_device_ptr} clause is private.

  \item A variable that is declared in a scope inside the \code{target}
  construct is private.

\end{itemize}

The data-mapping attributes for all other variables referenced in a
\code{target} construct are implicitly determined according to the following
rules: \begin{itemize}

  \item If the variable is not a scalar variable, the variable is mapped
  with a \emph{map-type} of \code{tofrom}.

  \item If the \code{target} construct does not have a
  \code{defaultmap(tofrom:scalar)} clause, then a \emph{scalar} variable is
  \code{firstprivate}.  

  \item If the \code{target} construct has a \code{defaultmap(tofrom:scalar)}
  clause, then a \emph{scalar} variable is mapped with a \emph{map-type} of
  \code{tofrom}.

  \index{Array section!Pointer-based}
  \item A pointer variable that appears in a pointer based array section in
  C/C++ is \code{private}.

\end{itemize}

\index{Mapped variable!Scalar}
In general, variables with implicitly determined data-mapping attributes are
treated as if they had appeared in a \code{map} clause with a \emph{map-type}
of \code{tofrom}.  The exception is scalar and C/C++ pointer variables.
Scalar variables have a base language built-in type (for example, \code{int} or
\code{float} in C/C++).\footnote{The precise definition of a scalar variable is
determined by the base language.}  

The performance overhead of a mapped variable can be higher than a \code{private}
variable.  A mapped variable requires a presence check to see if the variable
is already present in the accelerator's device data environment.
Variables that are \code{private} do not require this check.  
The overhead of performing the presence
check is more pronounced for the smaller variables, such as scalars.  For these reasons,
the implicit data-sharing attribute for scalar variables referenced in a
\code{target} construct is \code{firstprivate}.  However, the
\code{defaultmap(tofrom:scalar)} clause is provided to change the implicit
data-mapping attribute for these variables to mapped with a \emph{map-type} of
\code{tofrom}.

%In addition, many implementations use something similar to a remote procedure
%call to start a target region executing on an accelerator.  It is very
%efficient to pass scalar variables by value as arguments to the remote
%procedure.  Passing arguments by value happens to match quite nicely to the
%semantics of firstprivate.

\index{Accelerators!Initial thread}
\index{Array section}
In the \code{saxpy()} function shown in Figure~\ref{figure:chapter6-defaultmap-v1}, the
scalar variables \code{a} and \code{n} are \code{firstprivate}.  
%The pointer variables $y$ and
%$x$ are \code{private}, since they are used in array sections
%(see Section~\ref{ssec:06.array-sections}).  
Because they are used in array sections, the
The pointer variables \code{y} and
\code{x} are \code{firstprivate} and initialized with the address of the corresponding
array section in the accelerator's device data environment
(see Section~\ref{ssec:06.array-sections}).\footnote{The original
pointer value is discarded when the host and accelerator do not share the same address space.}
Each initial thread created by the
\code{target teams} construct at line $3$ gets a private instance of \code{a}, \code{n},
\code{y} and \code{x}.  

\begin{figure*}[!tb]
\begin{verbatim}
 1 void saxpy(float *restrict y, float *restrict x, float a, int n)
 2 {
 3   #pragma omp target teams map(y[:n]) map(to:x[:n]) 
 4   {
 6     #pragma omp distribute 
 7     for (int i=0; i<n; i++) {
 8         y[i] =  y[i] + a*x[i];
 9     } // End of distribute
10   } // End of target teams
11 }
\end{verbatim}
\caption{ \textbf {Example of default data-mapping attribute rules} -- \small
          The pointer variables \texttt{x} and \texttt{y} are \texttt{private}. The 
          scalar variables \texttt{a} and \texttt{n} are \texttt{firstprivate}.
         }
\label{figure:chapter6-defaultmap-v1}
\end{figure*}

Notice that if a variable is \code{firstprivate}, then any changes to that variable in
the target region will not be reflected back to the original variable.  This
can result in unexpected results.  For example, in
Figure~\ref{figure:chapter6-defaultmap-v2} the variable \code{sum} is \code{firstprivate}.
After the target region completes at line $8$, the computed value of \code{sum} is
lost, and the \code{dotp()} function always returns $0.0$.
To correct the problem with the \code{sum} variable, either place
it in a \code{map} clause or add a \code{defaultmap(tofrom:scalar)}
clause to the \code{target} construct.  It is recommended to not
rely on implicit behavior and instead list variables explicitly in \code{map},
\code{private}, or \code{firstprivate} clauses as appropriate.

\begin{figure*}[!tb]
\begin{verbatim}
 1 float dotp(float *restrict y, float *restrict x, int n)
 2 {
 3   float sum = 0.0;
 4   #pragma omp target map(y[:n]) map(to:x[:n])
 5   {
 6     for (int i=0; i<n; i++)
 7       sum += y[i] * x[i];
 8   } // End of target
 9
10   return sum;
11 }
\end{verbatim}
\caption{ \textbf {Example of problems with implicit firstprivate variables} -- \small
          Because the variable \texttt{sum} is \texttt{firstprivate}, the computed value
          of \texttt{sum} is lost at the end of the target region.
         }
\label{figure:chapter6-defaultmap-v2}
\end{figure*}

%-----------------------------------------------------------------------
%------------------------- New subsection ------------------------------
%-----------------------------------------------------------------------
\subsubsection{Pointers and Zero-length Array Sections}
\label{ssec:06.zero-array-sections}
\index{Array section!Zero-length}
\index{Array section!Pointer-based}
\index{Mapped variable!Array section}

In Section~\ref{ssec:06.array-sections}, we showed how array sections are used
to map memory that a pointer variable points to.  Recall that an
array section has a length.  If the length of an array section is zero, then it
is a \emph{zero-length array section}.

A pointer-based zero-length array section has a special meaning in a
\code{map} clause on a \code{target} construct.  The pointer variable is
\code{private} in the target region.  If the value of the original pointer is
an address that is already mapped, then the corresponding \code{private} pointer variable in the
\code{target} region is assigned the corresponding device address.  If the
value of the original pointer is an address that is not mapped, then the corresponding
\code{private} pointer variable is assigned NULL.

% Moved for placement in latex? 
\begin{figure*}[!tb]
\begin{verbatim}
 1 #include <stdlib.h>
 2 void f()
 3 {
 4    char *p, *q, A[128];
 5    extern void f1(char *);
 6    #pragma omp declare target to(f1) 
 7 
 8    p = malloc(1024);
 9    q = A;
10 
11    #pragma omp target data map(p[:1024], A)
12    {
13      #pragma omp target map(p[:0])
14      f1(p);
15 
16      #pragma omp target // Implicit map(q[:0])
17      f1(q);
18 
19      #pragma omp target map(p)
20      f1(p); // Error 
21    }
22    free(p);
23 }
\end{verbatim}
\caption{ \textbf {Example of C/C++ pointers as zero-length array sections} -- \small
          Pointer variables are implicitly treated as pointer-based zero-length array
          sections in target regions.
         }
\label{figure:chapter6-zerolength}
\end{figure*}

A pointer-based zero-length array section is convenient when a pointer variable is
used in a \code{target} construct, and the memory it points to was mapped (for
example, by an enclosing target data region) before the \code{target} construct is
encountered.  The code that uses the pointer variable in the target region 
might not refer to the length of the pointed-to memory.

%Pointer-based zero-length array sections are useful when accessing memory that
%has already been mapped and the length of that mapped memory may not
%be required by the code in the associated target region.

\index{Mapped variable!Data-mapping attribute}
Pointer variables referenced in a \code{target} construct that have an implicit
data-mapping attribute are treated as if they had appeared in a \code{map}
clause as the pointer variable in a zero-length array section with a
\emph{map-type} of \code{tofrom}.  Some simple examples using zero-length array
section are shown in Figure~\ref{figure:chapter6-zerolength}.

The \code{map} clause on the \code{target data} construct on line $11$ maps the
array \code{A} and the dynamically allocated memory that \code{p} points to.  The pointer
variable \code{p} is not mapped.  Because it appears in an array section, the
pointer variable \code{p} is \code{private} in the \code{target} construct starting at line
$13$.  The \code{private} variable \code{p} is assigned the corresponding device address of
the memory allocated at line $8$.

%You can think of this as look-up operation that checks to see if the pointer is
%pointing at mapped memory and if it is to just use the corresponding address of
%the mapped mapped.

For the \code{target} construct at line $16$, the pointer variable \code{q} is
implicitly treated as if it appeared in a \code{map} clause in a zero-length
array section.  At line $17$, \code{q} is a private pointer variable that is pointing
at the device address of the mapped array \code{A}.  If you explicitly map a pointer
variable as shown in line $19$, then you are mapping the value of a host
address to the accelerator.  The mapped pointer variable does not contain a
valid accelerator memory address.  The call to \code{f1()} will possibly de-reference
the invalid address stored in \code{p}.

%-----------------------------------------------------------------------
%------------------------- New section ---------------------------------
%-----------------------------------------------------------------------
\subsection{The Declare Target Directive}
\label{sec:06.declare-target-construct}
\index{OpenMP constructs!Declare target}
\index{Accelerators!Declare target}

The \code{declare target} construct is used for both functions and variables.
If a function is called from a target region, then the name of the function must
appear in a \code{declare target} directive.  The \code{declare}~\code{target}
directive is used to map global variables to an accelerator's device data
environment for the whole execution of the program.
The \code{declare target} construct syntax in C/C++ and Fortran is shown in
Figure~\ref{figure:syntax-declare-target-construct} along with its supported clauses.

\index{OpenMP clauses!to}
\index{OpenMP clauses!link}
\index{Accelerators!To clause}
\index{Accelerators!Link clause}
\begin{figure*}[!tb]
\centering
\begin{tabular}{|l|}
\hline
\ompbcdeclaretarget \\
\hspace{2em}\emph{declarations-definitions-seq} \\
\ompbcdeclaretargetend \\
\hspace{2em}\emph{or} \\
\ompbcdeclaretarget \emph{(extended-list)} \\
\hspace{2em}\emph{or} \\
\ompbcdeclaretarget{ \emph{clause[[[,] clause] \ldots]}} \\
\hline
\ompbfdeclaretarget \emph{(extended-list)} \\
\hspace{2em}\emph{or} \\
\ompbfdeclaretarget \ompclauses \\
\hline
\emph{where clause is:} \\
\bdeclto \\
\hspace{2em}\emph{or} \\
\blink \\
\hline
\end{tabular}
\caption{ \textbf{Syntax of the declare target construct in C/C++ and 
               Fortran} -- \small
          The various syntactical forms of the directive result in a 
          \emph{extended-list} of variable and function names.
          }
\label{figure:syntax-declare-target-construct}
\end{figure*}

The various syntactical forms of the \code{declare}~\code{target} directive result
in an \emph{extended-list} of variable and function names, or in the case of
the \code{link} clause, a list of variable names.  In describing the
functionality, we will refer to a function or variable name that appears
in a \code{declare}~\code{target} directive.

In C/C++, the \code{declare}~\code{target} and
\code{end}~\code{declare}~\code{target} directives provide a convenient means
to create an \emph{extended-list} of the names of variables and functions that are
declared between the two directives, where the variable declarations are at
file or namespace scope and the function declarations are at file, namespace, or
class scope.
An \emph{extended-list} of function and variable names may appear as list items on
the directive or in clauses.  The \code{to} clause accepts an
\emph{extended-list} of variable and function names.  The \code{link} clause
accepts only a list of variable names.  
In Fortran, the \code{declare}~\code{target} directive without clauses or an
\emph{extended-list} may appear in the interface specification for a
subroutine, function, program or module. 

%\footnote{See the \OMPfourfive Specification Section 2.10.6 for specific
%restrictions related to Fortran procedures and variables}.

\index{Accelerators!Mapped function}
If a function name appears in a \code{declare}~\code{target} directive in the
same translation unit as the definition of the function, then it is a
\emph{mapped}~\emph{function}.  A mapped function has a corresponding
accelerator-specific version of the function.  A function name must appear in a
\code{declare}~\code{target} directive before the function is called from a
\code{target} construct or another mapped function.

A variable whose name appears in the \code{declare}~\code{target} directive
must have static storage duration.  In C/C++, these are variables that are
declared at file, namespace, static-block, or static-class scope. In Fortran,
these are named variables and named common blocks.

\index{Mapped variable!Globally mapped}
A variable name that appears in a \code{declare}~\code{target} directive in
the same translation unit where it is defined is 
\emph{globally}~\emph{mapped}.  
If the variable is referenced in a mapped function or
device construct, it must appear in a \code{declare}~\code{target} directive in
the same translation unit as the function or construct.

A variable that is globally mapped is created and initialized in an
accelerator's device data environment before a program begins execution.
Globally mapped variables have an infinite reference count and are never
removed from an accelerator's device data environment.  They are permanently
mapped for the execution of the whole program.  Some examples of the
\code{declare}~\code{target} directive are shown in
Figure~\ref{figure:chapter6-decltarg}.

\begin{figure*}[!tb]
\begin{verbatim}
 1 int Lastpos = 0;
 2 extern char Buf[128];
 3 #pragma omp declare target(Lastpos, Buf)
 4 
 5 extern int F(int, int);
 6 #pragma omp declare target to(F)
 7 
 8 #pragma omp declare target
 9 int State = -1;
10 extern int search(char *);
11 
12 void find_state(char c)
13 {
14   int pos;
15   Buf[Lastpos] = c;
16   pos = search(Buf);
17   Lastpos = pos;
18   State = F(Lastpos, pos);
19 }
20 #pragma omp end declare target
21 
22 void process_input(char c)
23 {
24   #pragma omp target firstprivate(c)
25   find_state(c);
26 }
\end{verbatim}
\caption{ \textbf {Example of the declare target directive} -- \small
          Various forms of the directive all have the same effect.
         }
\label{figure:chapter6-decltarg}
\end{figure*}

The first form of the \code{declare}~\code{target} directive on line $3$
declares that the variables \code{Lastpos} and \code{Buf} are globally mapped.  The
original \code{Lastpos} variable on the host and an accelerator's corresponding
version of the variable are initialized to $0$.  The variable \code{Buf} is declared
but not defined in the example.  \code{Buf} must appear in a
\code{declare}~\code{target} directive in the place where \code{Buf} is defined.

The \code{declare}~\code{target} directive on line $6$ uses the \code{to}
clause to declare that \code{F()} is a mapped function.  The prototype
of the function \code{F()} is declared, but \code{F()} is not defined in the example.  The
function name \code{F} must appear in a \code{declare}~\code{target} directive in
the place (some other file) where the definition of \code{F()} occurs.

The \code{declare}~\code{target} on line $8$ and the
\code{declare}~\code{end}~\code{target} on line $20$ declare that variable
\code{State} and \code{search()} and \code{find\_state()} are mapped functions.  The
host's original variable \code{State} and an accelerator's corresponding version of
the variable are initialized to $-1$.  Like \code{F}, the function name \code{search}
must appear in a \code{declare}~\code{target} directive where it is defined.
The function \code{find\_state()} is both declared and defined between the pair of
directives, and an accelerator-specific version of it is generated.  The call to
\code{find\_state()} appears inside a \code{target} construct at lines $24-25$.  When
an initial thread executes the target region, the accelerator-specific version of the
\code{find\_state()} function is invoked.
\index{Accelerators!Initial thread}

\index{Accelerators!Mapped function}
\index{Mapped variable!Globally linked}
\index{Accelerators!Device data environment}
\index{Device data environment}
A variable that is globally mapped will reserve memory in an accelerator's
device data environment for the whole program.  The \code{link} clause provides
another way to access a global variable in a mapped function without having to
globally map the variable.  Note that function names cannot appear in a
\code{link} clause.  The \code{link} clause declares that a variable is
\emph{globally linked}.  A reference to a globally linked variable can appear
in a mapped function with the restriction that before the function is called
from a target region, the variable will have been mapped by a \code{map}
clause.

An example of \code{link} clause is shown in Figure~\ref{figure:chapter6-link}.
On line $2$ the variable \code{Vector} is globally linked by the
\code{declare}~\code{target} directive, which declares that the global
variable \code{Vector} will be mapped before the \code{compute()} function is executed on
the accelerator.  The \code{map} clause on the \code{target} construct at line
$15$ maps \code{Vector}.  The call to \code{compute()} in the target region can then
find the mapped \code{Vector} variable.  

%If $Vector$ had not been mapped, then a runtime error might occur.

\begin{figure*}[!tb]
\begin{verbatim}
 1 float Vector[1024];
 2 #pragma omp declare target link(Vector)
 3 
 4 #pragma omp declare target
 5 extern float F(float , float);
 6 int compute(float a)
 7 {
 8    for (int i=0; i<1024; i++)
 9       Vector[i] = F(Vector[i], a);
10 }
11 #pragma omp end declare target
12 
13 int update_vector(float a)
14 {
15   #pragma omp target map(Vector) firstprivate(a)
16   compute(a);
17 }
\end{verbatim}
\caption{ \textbf {Example of the link clause on a declare target directive} -- \small
          Variables appearing in the \texttt{link} clause are \emph{globally linked}.  
          They must be mapped before they are referenced in a mapped function.
         }
\label{figure:chapter6-link}
\end{figure*}

%-----------------------------------------------------------------------
%------------------------- New section ---------------------------------
%-----------------------------------------------------------------------
\subsection{The Data-mapping Constructs}
\label{sec:06.data_mapping_constructs}

This section describes a group of constructs that map variables and manage the
consistency of mapped variables between the host and an accelerator.  A
map-enter and map-exit phase occurs at the entry and exit of each target region
for variables that are mapped in the region.  Redundantly mapping a variable in
multiple target regions can be detrimental to performance, especially when the
host and the accelerator do not share memory.
\index{Mapped variable!Map-enter phase}
\index{Mapped variable!Map-exit phase}

The \code{target}~\code{data} construct described in
Section~\ref{ssec:06.target_data_construct} maps variables across a region of
code that encloses multiple target regions.  Variables are mapped once and then
used in many enclosed target regions.  The
\code{target}~\code{enter}~\code{data} and
\code{target}~\code{exit}~\code{data} construct are not associated with a
specific code region and perform only the map-enter or map-exit phase,
respectively.  These two unstructured constructs are described in
Section~\ref{ssec:06.target-enter-and-exit-data-constructs}.  Once a variable
is mapped, the \code{target}~\code{update} construct described in Section~
\ref{ssec:06.target_update_construct} can be used to make its value consistent
between the host and the accelerator where it is mapped.


%-----------------------------------------------------------------------
%------------------------- New subsection ------------------------------
%-----------------------------------------------------------------------
\subsubsection{The Target Data Construct}
\label{ssec:06.target_data_construct}
\index{OpenMP constructs!Target data}
\index{Accelerators!Target data}
\index{Mapped variable}

\index{Accelerators!Device data environment}
\index{Device data environment}
The \code{target data} construct maps variables to a device data environment
for the extent of the target data region.  In other words, when a thread
executing on the host device encounters a \code{target data} construct,
variables appearing in \code{map} clauses on the construct are mapped according
to the map-enter phase.  However, unlike the \code{target} construct, the host
thread continues executing the code inside the target data region.  Once the
host thread encounters the end of the target data region, the map-exit phase
occurs for the variables that appeared in the \code{map} clauses on the
construct. 
\index{Mapped variable!Map-enter phase}
\index{Mapped variable!Map-exit phase}

In summary, a \code{target data} construct is like a \code{target} construct
minus the code executing on the accelerator.  It only maps variables.  The
\code{target data} construct syntax in C/C++ and Fortran is shown in
Figure~\ref{figure:syntax-target-data-construct}.

\begin{figure*}[!tb]
\centering
\begin{tabular}{|l|}
\hline
\ompbctargetdata \ompclauses  \\
\hspace{2em}\emph{structured block} \\
\hline
\ompbftargetdata \ompclauses \\
\hspace{2em}\emph{structured block} \\
\ompbftargetdataend \\
\hline
\end{tabular}
\caption{ \textbf{Syntax of the target data construct in C/C++ and 
               Fortran} -- \small
          Map variables to a device for the extent of the region.
          }
\label{figure:syntax-target-data-construct}
\end{figure*}

Clauses that can appear on the \code{target}~\code{data} 
construct are shown in Figure~\ref{figure:syntax-target-data-clauses}.

\index{OpenMP clauses!if}
\index{OpenMP clauses!map}
\index{OpenMP clauses!device}
\index{OpenMP clauses!use\_device\_ptr}
\index{Accelerators!If clause}
\index{Accelerators!Map clause}
\index{Accelerators!Device clause}
\index{Accelerators!Use\_device\_ptr clause}
\begin{figure*}[!tb]
\centering
\begin{tabular}{|l l|}
\hline
\bciftargetdata & (C/C++)\\
\bfiftargetdata & (Fortran)\\
\bmap & \\
\bcdevice & (C/C++)\\
\bfdevice & (Fortran)\\
\busedeviceptr & \\
\hline
\end{tabular}
\caption{ \textbf{Clauses supported by the target data construct} -- \small
          The \texttt{if} and \texttt{device} clauses are discussed in
          Section~\ref{sec:06.which-device}. The \texttt{map} clause is discussed in
          Section~\ref{sec:06.map-clause}.  The \texttt{use\_device\_ptr}
          clause is discussed in Section~\ref{ssec:06.use_device_ptr-clause}.
          }
\label{figure:syntax-target-data-clauses}
\end{figure*}

On entry to and exit from a target data region, map-entry and map-exit phases
occur, respectively, for the variables that appear in \code{map} clauses on the
construct.  An original variable can have only one corresponding variable in an
accelerator's device data environment (See Section~\ref{sec:06.map-clause}).
When a variable is mapped by a \code{target}~\code{data} construct, all device
constructs enclosed in the target data region that also map that variable will
find a corresponding variable present in the accelerator's device data
environment and use it. An example of a \code{target}~\code{data} construct
that encloses two \code{target} constructs is shown in
Figure~\ref{figure:chapter6-target-data-v1}.

\begin{figure*}[!tbhp]
\begin{verbatim}
 1 #define N (1024*1024)
 2 double A[N], B[N];
 3 extern double F(double * restrict);
 4 
 5 void G(double c, double d)
 6 {
 7   double e;
 8   #pragma omp target data map(B)
 9   {
10     #pragma omp target map(B) map(always,from:A) \
11                        firstprivate(c,d)
12     for (int i=0; i<N; i++)
13       A[i] =  B[i] * c + d;
14 
15     e = F(A);
16 
17     #pragma omp target map(B) firstprivate(e)
18     for (int i=0; i<N; i++)
19       B[i] =  B[i] / e;
20 
21   } // End of target data
22 }
\end{verbatim}
\caption{ \textbf {Example of a target data construct} -- \small
          The array variable \texttt{B} is mapped once to an accelerator
          across two target regions.
         }
\label{figure:chapter6-target-data-v1}
\end{figure*}

The variable \code{B} is mapped by the \code{target}~\code{data} construct at line
$8$, which encloses the two \code{target} constructs at lines $10$
and $17$.  Storage is allocated in the accelerator's device data environment
for the corresponding \code{B} variable, assigned the value of the host's
original \code{B} variable, and its reference count is initialized to one.

The host thread that encounters the \code{target}~\code{data} construct
executes the code inside the target data region.  It encounters the \code{target}
construct at line $10$, which maps \code{B}.  During its map-enter phase, \code{B} is found
to already be present in the accelerator's device data environment and the
reference count for \code{B} is incremented to two.  When the target region completes
and during the map-exit phase, the reference count for \code{B} is decremented back
to one.  \code{B} is not removed from the accelerator's device data environment.

After the target region spanning lines $10-13$ has completed, the host thread
continues executing the code in the target data region calling the function \code{F()} at
line $15$ and then encountering the second \code{target} construct at line
$17$.  The reference count for the variable \code{B} is again incremented at the
entry to and decremented at the exit from the target region.  Because it still
has a reference count greater-than zero, \code{B} remains mapped.

Finally, the host thread continues execution after the second target region is
complete and then completes the target region at line $21$.  During the map-exit
phase for the variable \code{B}, its reference count is decremented to zero, the
value of the accelerator's corresponding \code{B} variable is copied to the host's
original \code{B} variable, and the storage for \code{B} on the accelerator is released.

The variable \code{A} may be mapped by a \code{target data} or \code{target enter data} construct 
before the function \code{G()} is called, and so it would be present in the accelerator's
device data environment with a non-zero reference count.
However, the updated value of \code{A} is always needed for the call to \code{F()} at line $15$.
The \code{always} \emph{map-type} in the \code{map} clause on line $10$ ensures
that, regardless of the reference count for \code{A}, after the associated target
region completes, the value of the variable \code{A} on the host and the accelerator
is always consistent (the same).  

%-----------------------------------------------------------------------
%------------------------- New subsection ------------------------------
%-----------------------------------------------------------------------
\subsubsection{The Target Update Construct}
\label{ssec:06.target_update_construct}
% Ruud - Changed to lowercase
\index{OpenMP constructs!Target update}
\index{Accelerators!Target update}

\index{Mapped variable}
If a variable is mapped by the \code{target}~\code{data} or
\code{target}~\code{enter}~\code{data} constructs or by the
\code{declare}~\code{target} directive, there are instances when a host thread
might need to access the mapped variable.  The \code{target update} construct
makes the value of a mapped variable the same on the host as on an
accelerator.  It either assigns the value of the host's original variable to
the accelerator's corresponding variable, or it assigns the
value of the corresponding variable to the original variable. It makes the
original and corresponding variables consistent.  The \code{target update}
construct syntax in C/C++ and Fortran is given in
Figure~\ref{figure:syntax-target-update-construct}.

\begin{figure}[!tb]
\centering
\begin{tabular}{|l|}
\hline
\ompbctargetupdate \ompclauses  \\
\hline
\ompbftargetupdate \ompclauses \\
\hline
\end{tabular}
\caption{ \textbf{Syntax of the target update construct in C/C++ and 
               Fortran} -- \small
          Make the value of a mapped variable consistent between the
          host and an accelerator.
          }
\label{figure:syntax-target-update-construct}
\end{figure}

The clauses that are
available on the \code{target}~\code{update} construct are shown in
Figure~\ref{figure:syntax-target-update-clauses}.
\index{OpenMP clauses!if}
\index{OpenMP clauses!device}
\index{OpenMP clauses!nowait}
\index{OpenMP clauses!depend}
\index{OpenMP clauses!to}
\index{OpenMP clauses!from}
\index{Accelerators!If clause}
\index{Accelerators!Device clause}
\index{Accelerators!Nowait clause}
\index{Accelerators!Depend clause}
\index{Accelerators!To clause}
\index{Accelerators!From clause}
\begin{figure}[!htbp]
\centering
\begin{tabular}{|l l|}
\hline
\bciftargetupdate & (C/C++)\\
\bfiftargetupdate & (Fortran)\\
\bcdevice & (C/C++)\\
\bfdevice & (Fortran)\\
\bnowait & \\
\bdepend & \\
\bto & \\
\bfrom & \\
\hline
\end{tabular}
\caption{ \textbf{Clauses supported by the target update construct} -- \small
          The \texttt{if} and \texttt{device} clauses are discussed in
          Section~\ref{sec:06.which-device}. The \texttt{map} clause is discussed in
          Section~\ref{sec:06.map-clause}.  The \texttt{nowait} and \texttt{depend} clauses are
          discussed in Section~\ref{sec:06.async-exec}.  The \texttt{to} and \texttt{from} clauses
          are described below.
          }
\label{figure:syntax-target-update-clauses}
\end{figure}

\index{Mapped variable!Globally mapped}
An example using the \code{target}~\code{update} construct is shown in
Figure~\ref{figure:chapter6-target-update-v1}.  At line $4$ the array variable
\code{B} is globally mapped by the \code{declare}~\code{target} directive (see
Section~\ref{sec:06.declare-target-construct}).  

\begin{figure*}[!tb]
\begin{verbatim}
 1 #define N (1024*1024)
 2 extern void update_boundary(double *, int, int);
 3 double B[N];
 4 #pragma omp declare target(B)
 5 
 6 void G(double *restrict B, double e, int n, int l)
 7 {
 8   #pragma omp target update from(B[0:l],B[n-1-l:l])
 9   update_boundary(B, n, l);
10   #pragma omp target update to(B[0:1],B[n-1-l:l])
11 
12   #pragma omp target
13   for (int i=0; i<n; i++)
14     B[i] =  B[i] / e;
15 }
\end{verbatim}
\caption{ \textbf {Example of the target update construct} -- \small
          The array variable \texttt{B} is globally mapped.  The target update
          construct is used make elements at the start and the end the
          array \texttt{B} consistent between the host and the accelerator.
         }
\label{figure:chapter6-target-update-v1}
\end{figure*}

The \code{target}~\code{update} construct at line $8$ uses the \code{from}
clause to assign the first and last \code{l} elements of \code{B} from the accelerator's
corresponding \code{B} variable to the same elements in the host's original \code{B}
variable.  It makes the array elements consistent between the host and the
accelerator.  In this case, it is getting the values from the accelerator's
version of \code{B}.

Let us assume that the function \code{update\_boundary()} at line $9$ reads and then
writes only the \code{l} first and last elements of \code{B}. It updates the boundaries
of \code{B}.  When the host writes to the elements in \code{B}, those elements are no
longer consistent between the host and the accelerator.

The \code{target}~\code{update} construct at line $10$ then uses the \code{to}
clause to assign the first and last \code{l} elements of \code{B} from the host to the
sames elements in the accelerator's \code{B} variable.  It makes the array elements
consistent, but this time it is using the values from the host's version of
\code{B}.

Notice that the \code{target}~\code{update} construct is executed by a host thread.
The construct cannot appear in a target region.  This example used a variable
that was globally-mapped, but any mapped variable may appear in a \code{to} or
\code{from} clause (for example, one that was mapped by an enclosing target data
region).

%Suppose we extend the example in Figure~\ref{figure:chapter6-target-data-v1}.
%We want to map the variable once across the two enclosed target regions.
%However, we'd like to \emph{update} the variable $b$ with the host value
%between the two target regions.  In Figure~\ref{figure:chapter6-target-update}
%the \code{target update} construct with the \code{to} clause assigns the corresponding variable $b$ the value of the original variable $b$ after the valud of $b$ has been modified in the host data environment.
%
%TBD: Explain that this is a data race or at least undefined behavior without the \code{target update} construct.  If a write to a variable occurs on one device then another device cannot access that variable without an intevening target update construct to make the variable consistent across the two data environments.
%
%\begin{figure*}[!tbh]
%\begin{verbatim}
% 1 #pragma omp target data map(b)
% 2 {
% 3   #pragma omp target map(to:c,d,a)
% 4   for (i=0; i<count; count++)
% 5   {
% 6     a[i] =  b[i] * c + d;
% 7   }
% 8
% 9   e = F(a);
%10   for (i=0; i<count; i+=step)
%11      b[i] = G(b[i], step);
%12
%13   #pragma omp target update to(b)
%11
%12   #pragma omp target map(to:e)
%13   for (i=0; i<count; count++)
%14   {
%15     b[i] =  b[i] + e;
%16   }
%17 } // End of target data
%}
%\end{verbatim}
%\caption{ \textbf {Code fragment with a target update directive} -- \small
%          The variable b is mapped to a device data environment once
%          across two target regions and updated with the host value
%          between the target regions.
%         }
%\label{figure:chapter6-target-update}
%\end{figure*}

%-----------------------------------------------------------------------
%------------------------- New subsection ------------------------------
%-----------------------------------------------------------------------
\subsubsection{The Target Enter and Exit Data Constructs}
\label{ssec:06.target-enter-and-exit-data-constructs}
% Ruud - Changed to lowercase
\index{OpenMP constructs!Target enter data}
\index{OpenMP constructs!Target exit data}
\index{Accelerators!Target enter data}
\index{Accelerators!Target exit data}
\index{Mapped variable}

\index{Mapped variable!Map-enter phase}
\index{Mapped variable!Map-exit phase}
The \code{target}~\code{data} construct applies to a subsequent
structured block.
There is a map-enter phase that occurs on entry to and a map-exit phase that
occurs on exit from a target data region.  
However, sometimes the way we want to map variables does
not fit a structured block model.  We want to map variables in an
unstructured way. The target enter and exit data constructs provide this
capability.  These are standalone constructs that are not associated with a
statement or structured block of code.  When a host thread encounters the
\code{target}~\code{enter}~\code{data} construct, a map-enter phase occurs for
variables that appear in \code{map} clauses on the construct.  Similarly, a
map-exit phase occurs for variables in \code{map} clauses on the
\code{target}~\code{exit}~\code{data} construct when it is encountered. 

The syntax for the \code{target}~\code{enter}~\code{data} and
\code{target}~\code{exit}~\code{data} constructs in C/C++ and Fortran is
shown in Figure~\ref{figure:chapter6-target-enter-exit-data-constructs}.  

\index{Accelerators!Device data environment}
\index{Device data environment}
\begin{figure*}[!tb]
\centering
\begin{tabular}{|l|}
\hline
\ompbctargetenterdata \ompclauses  \\
\ompbctargetexitdata \ompclauses  \\
\hline
\ompbftargetenterdata \ompclauses \\
\ompbftargetexitdata \ompclauses \\
\hline
\end{tabular}
\caption{ \textbf{Syntax of the target enter and exit data constructs in 
               C/C++ and Fortran} -- \small
          Standalone constructs for mapping variables to and from
          an accelerator's device data environment.
          }
\label{figure:chapter6-target-enter-exit-data-constructs}
\end{figure*}

\index{Mapped variable}
\index{Mapped variable!Map-type}
\index{Mapped variable!Alloc map-type}
\index{Mapped variable!To map-type}
\index{Mapped variable!Delete map-type}
\index{Mapped variable!From map-type}
\index{Mapped variable!Release map-type}
The clauses that are available on the constructs are shown in
Figure~\ref{figure:chapter6-target-enter-exit-data-clauses}.  The
\emph{map-types} that may appear in a \code{map} clause on a
\code{target}~\code{enter}~\code{data} construct are restricted to \code{alloc}
and \code{to}.  The \emph{map-types} that may appear in a \code{map} clause on
a \code{target}~\code{exit}~\code{data} construct are restricted to
\code{release}, \code{from}, and \code{delete}.  An explicit \emph{map-type}
must be specified in \code{map} clauses on these constructs. A \code{tofrom}
\emph{map-type} is not legal in a \code{map} clause on either construct.  The
\code{delete} \emph{map-type} may appear only in a \code{map} clause on a
\code{target}~\code{exit}~\code{data} construct.  It sets the reference count
of a corresponding variable to zero and removes it from an accelerator.  Its
purpose is to force the removal of a variable from an accelerator's device data
environment no matter what its reference count is.

\index{OpenMP clauses!if}
\index{OpenMP clauses!map}
\index{OpenMP clauses!device}
\index{OpenMP clauses!nowait}
\index{OpenMP clauses!depend}
\index{Accelerators!If clause}
\index{Accelerators!Map clause}
\index{Accelerators!Device clause}
\index{Accelerators!Nowait clause}
\index{Accelerators!Depend clause}
\begin{figure}[!tb]
\centering
\begin{tabular}{|l l|}
\hline
\bciftargetenterdata & (C/C++)\\
\bciftargetexitdata & (C/C++)\\
\bfiftargetenterdata & (Fortran)\\
\bfiftargetexitdata & (Fortran)\\
\bmap & \\
\bcdevice & (C/C++)\\
\bfdevice & (Fortran)\\
\bnowait & \\
\bdepend & \\
\hline
\end{tabular}
\caption{ \textbf{Clauses supported by the target enter and exit data 
               constructs} -- \small
          The \texttt{if} and \texttt{device} clauses are discussed in
          Section~\ref{sec:06.which-device}. The \texttt{map} clause is discussed in
          Section~\ref{sec:06.map-clause}.  The \texttt{nowait} and \texttt{depend} clauses are
          discussed in Section~\ref{sec:06.async-exec}.
          }
\label{figure:chapter6-target-enter-exit-data-clauses}
\end{figure}
 
\index{Array section}
A C++ class declaration is shown in
Figure~\ref{figure:chapter6-target-enter-exit-data} with two member functions
\code{allocate()} and \code{release()}.  At line $9$, the
\code{target}~\code{enter}~\code{data} construct executes a map-enter phase for
a pointer-based array section. The pointer variable in the array section is
\code{p}, and it contains the address of the memory that was dynamically allocated
at line $6$.  The \code{alloc} \emph{map-type} indicates that the corresponding
memory for the array section on the accelerator is not initialized with any
value.

\begin{figure*}[!tb]
\begin{verbatim}
 1 class myArray {
 2   int length;
 3   double *ptr;
 4 
 5   void allocate(int l) {
 6     double *p = new double[l];
 7     ptr = p;
 8     length = l;
 9     #pragma omp target enter data map(alloc:p[0:length])
10   }
11 
12   void release() {
13     double *p = ptr;
14     #pragma omp target exit data map(release:p[0:length])
15     delete[] p;
16     ptr = 0;
17     length = 0;
18   }
19 };
\end{verbatim}
\caption{ \textbf {C++ Example of the target enter and exit data constructs} -- \small
          The \texttt{allocate()} method will execute a map-enter phase for the
          dynamically allocated memory pointed to by \texttt{p}.  The \texttt{release()}
          method will execute the corresponding map-exit phase.
         }
\label{figure:chapter6-target-enter-exit-data}
\end{figure*}

\index{Array section!Pointer-based}
At line $16$, in the \code{release()} member function, the
\code{target}~\code{exit}~\code{data} construct executes a map-exit phase for a
pointer-based array section.  It is expected that the class member \code{ptr} is
still pointing at the memory allocated in the \code{allocate()} member function.  The
locally scoped pointer variable \code{p} is assigned the value of \code{ptr} and then
used in the pointer-based array section.  The \code{release} \emph{map-type} in the
\code{map} clause frees the corresponding storage for the array section in the
accelerator's device data environment.  The corresponding array section is not
copied back to the original host memory.

Notice that the array sections in both \code{map} clauses are examples of
pointer-based array sections where only the pointed-to memory is mapped and not
the pointer variable itself.  The locally scoped \code{p} variables are required
because the C++ \code{this->ptr} is an lvalue expression, not a pointer variable.
The variable that appears in an array section must be an array name or a
pointer variable.

%It is evident that the type of programming pattern shown in
%Figure~\ref{figure:chapter6-delete} does not lend itself to the
%structured block requirement of the \code{target}~\data{data} construct.  

An example using the \code{delete} \emph{map-type} is shown in
Figure~\ref{figure:chapter6-delete-maptype}.  Line $5$ is executed zero or more
times depending on the value of the variable \code{v}.  Each time a host thread
executes the \code{target}~\code{enter}~\code{data} construct, a map-enter phase
occurs for \code{S}.  The first map-enter phase allocates storage, initializes
the corresponding variable \code{S} with the value of the host's original \code{S}
variable, and sets the corresponding variable's reference count to one.  Each
subsequent map-enter phase increments the reference count.  The
\code{map} clause on the \code{target}~\code{exit}~\code{data} construct on
line $8$ uses the \code{delete} \emph{map-type} to set the reference count of \code{S} to
zero.  The variable \code{S} is then removed from the accelerator's device data
environment.  The value of \code{S} on the host after line $9$ is undefined since
the \code{delete} \emph{map-type} does not copy the corresponding variable back
to the original host variable.

\begin{figure*}[!tb]
\begin{verbatim}
1 void G(char S[128], int v)
2 {
3   extern int mutate(char *s, int);
4   while (!v) {
5     #pragma omp target enter data map(to:S)
6     v = mutate(S, v);
7   }
8   #pragma omp target exit data map(delete:S)
9 }
\end{verbatim}
\caption{ \textbf {Example of the delete map-type} -- \small
          Regardless of its reference count, remove \texttt{S} from an     
          accelerator's device data environment.
         }
\label{figure:chapter6-delete-maptype}
\end{figure*}

When a variable appears in a \code{map} clause on a
\code{target}~\code{exit}~\code{data} construct and that variable is not
present in the accelerator's device data environment, then it is ignored
by the construct.  For example, in the case where the variable \code{v} is 0 on
entry to the function, the \code{target}~\code{exit}~\code{data} construct at
line $8$ does nothing.

The \code{target}~\code{enter}~\code{data} and \code{data}~\code{exit}~\code{data} 
constructs have another potential benefit.  Using the
\code{nowait} clause, the constructs may execute as
deferrable tasks (see section~ \ref{sec:06.async-exec}).  This enables the
possibility of asynchronously executing map-enter and map-exit data transfers
while the host thread continues executing other tasks in parallel.

